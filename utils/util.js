/**\n * 工具函数库\n */\n\n/**\n * 格式化时间\n * @param {Date} date 日期对象\n * @return {string} 格式化后的时间字符串 YYYY/MM/DD HH:mm:ss\n */\nconst formatTime = date => {\n  const year = date.getFullYear()\n  const month = date.getMonth() + 1\n  const day = date.getDate()\n  const hour = date.getHours()\n  const minute = date.getMinutes()\n  const second = date.getSeconds()\n\n  return `${[year, month, day].map(formatNumber).join('/')} ${[hour, minute, second].map(formatNumber).join(':')}`\n}\n\n/**\n * 格式化数字\n * @param {number} n 数字\n * @return {string} 格式化后的数字字符串，个位数补0\n */\nconst formatNumber = n => {\n  n = n.toString()\n  return n[1] ? n : `0${n}`\n}\n\n/**\n * 日期格式化，支持多种格式\n * @param {Date|string|number} date 日期对象、时间字符串或时间戳\n * @param {string} format 格式字符串，如 YYYY-MM-DD HH:mm:ss\n * @return {string} 格式化后的时间字符串\n */\nconst formatDate = (date, format = 'YYYY-MM-DD') => {\n  if (!date) return '';\n  \n  // 转换为Date对象\n  if (typeof date === 'string' || typeof date === 'number') {\n    date = new Date(date);\n  }\n  \n  // 无效日期\n  if (isNaN(date.getTime())) return '';\n  \n  const year = date.getFullYear();\n  const month = date.getMonth() + 1;\n  const day = date.getDate();\n  const hour = date.getHours();\n  const minute = date.getMinutes();\n  const second = date.getSeconds();\n  \n  return format\n    .replace(/YYYY/g, year)\n    .replace(/YY/g, String(year).slice(2))\n    .replace(/MM/g, month < 10 ? `0${month}` : month)\n    .replace(/M/g, month)\n    .replace(/DD/g, day < 10 ? `0${day}` : day)\n    .replace(/D/g, day)\n    .replace(/HH/g, hour < 10 ? `0${hour}` : hour)\n    .replace(/H/g, hour)\n    .replace(/hh/g, hour < 10 ? `0${hour}` : hour)\n    .replace(/h/g, hour % 12 || 12)\n    .replace(/mm/g, minute < 10 ? `0${minute}` : minute)\n    .replace(/m/g, minute)\n    .replace(/ss/g, second < 10 ? `0${second}` : second)\n    .replace(/s/g, second);\n}\n\n/**\n * 将距离格式化为更友好的显示方式\n * @param {number} distance 距离，单位 米\n * @return {string} 格式化后的距离\n */\nconst formatDistance = (distance) => {\n  if (typeof distance !== 'number') return '';\n  \n  if (distance < 1000) {\n    return `${Math.round(distance)}米`;\n  } else if (distance < 10000) {\n    return `${(distance / 1000).toFixed(1)}公里`;\n  } else {\n    return `${Math.round(distance / 1000)}公里`;\n  }\n}\n\n/**\n * 将时间差格式化为友好的显示方式\n * @param {Date|string|number} date 日期\n * @return {string} 格式化后的时间差，如"刚刚"、"5分钟前"等\n */\nconst timeAgo = (date) => {\n  if (!date) return '';\n  \n  // 转换为Date对象\n  if (typeof date === 'string' || typeof date === 'number') {\n    date = new Date(date);\n  }\n  \n  // 无效日期\n  if (isNaN(date.getTime())) return '';\n  \n  const now = new Date();\n  const diff = (now - date) / 1000; // 秒数\n  \n  if (diff < 60) {\n    return '刚刚';\n  } else if (diff < 3600) {\n    return `${Math.floor(diff / 60)}分钟前`;\n  } else if (diff < 86400) {\n    return `${Math.floor(diff / 3600)}小时前`;\n  } else if (diff < 2592000) {\n    return `${Math.floor(diff / 86400)}天前`;\n  } else if (diff < 31536000) {\n    return `${Math.floor(diff / 2592000)}个月前`;\n  } else {\n    return `${Math.floor(diff / 31536000)}年前`;\n  }\n}\n\n/**\n * 防抖函数\n * @param {Function} fn 需要防抖的函数\n * @param {number} delay 延迟时间，单位毫秒\n * @return {Function} 防抖后的函数\n */\nconst debounce = (fn, delay = 500) => {\n  let timer = null;\n  return function(...args) {\n    if (timer) clearTimeout(timer);\n    \n    timer = setTimeout(() => {\n      fn.apply(this, args);\n      timer = null;\n    }, delay);\n  };\n}\n\n/**\n * 节流函数\n * @param {Function} fn 需要节流的函数\n * @param {number} interval 间隔时间，单位毫秒\n * @return {Function} 节流后的函数\n */\nconst throttle = (fn, interval = 300) => {\n  let last = 0;\n  return function(...args) {\n    const now = Date.now();\n    if (now - last >= interval) {\n      fn.apply(this, args);\n      last = now;\n    }\n  };\n}\n\n/**\n * 生成UUID\n * @return {string} UUID\n */\nconst uuid = () => {\n  return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function(c) {\n    const r = Math.random() * 16 | 0;\n    const v = c === 'x' ? r : (r & 0x3 | 0x8);\n    return v.toString(16);\n  });\n}\n\n/**\n * 将对象转换为URL查询字符串\n * @param {Object} obj 对象\n * @return {string} URL查询字符串\n */\nconst objectToQuery = (obj) => {\n  if (!obj) return '';\n  return Object.keys(obj)\n    .filter(key => obj[key] !== undefined && obj[key] !== null)\n    .map(key => `${encodeURIComponent(key)}=${encodeURIComponent(obj[key])}`)\n    .join('&');\n}\n\n/**\n * 从URL查询字符串解析参数\n * @param {string} url URL字符串\n * @return {Object} 解析后的参数对象\n */\nconst queryToObject = (url) => {\n  const result = {};\n  const queryString = url.split('?')[1] || '';\n  \n  if (!queryString) return result;\n  \n  queryString.split('&').forEach(item => {\n    const pair = item.split('=');\n    if (pair.length === 2) {\n      result[decodeURIComponent(pair[0])] = decodeURIComponent(pair[1]);\n    }\n  });\n  \n  return result;\n}\n\n/**\n * 深拷贝对象\n * @param {*} obj 需要深拷贝的对象\n * @return {*} 深拷贝后的对象\n */\nconst deepClone = (obj) => {\n  if (obj === null || typeof obj !== 'object') return obj;\n  \n  if (obj instanceof Date) return new Date(obj);\n  if (obj instanceof RegExp) return new RegExp(obj);\n  \n  const clone = Array.isArray(obj) ? [] : {};\n  \n  for (const key in obj) {\n    if (Object.prototype.hasOwnProperty.call(obj, key)) {\n      clone[key] = deepClone(obj[key]);\n    }\n  }\n  \n  return clone;\n}\n\n/**\n * 获取文件扩展名\n * @param {string} filename 文件名\n * @return {string} 文件扩展名，如 .jpg\n */\nconst getFileExtension = (filename) => {\n  if (!filename) return '';\n  return filename.substring(filename.lastIndexOf('.'));\n}\n\n/**\n * 格式化货币\n * @param {number} amount 金额\n * @param {number} decimals 小数位数\n * @param {string} currency 货币符号\n * @return {string} 格式化后的货币\n */\nconst formatCurrency = (amount, decimals = 2, currency = '¥') => {\n  if (typeof amount !== 'number') return '';\n  return currency + amount.toFixed(decimals);\n}\n\n/**\n * 检查对象是否为空\n * @param {Object} obj 对象\n * @return {boolean} 是否为空\n */\nconst isEmptyObject = (obj) => {\n  if (!obj || typeof obj !== 'object') return true;\n  return Object.keys(obj).length === 0;\n}\n\n/**\n * 数字千分位格式化\n * @param {number} num 数字\n * @return {string} 格式化后的数字\n */\nconst formatThousands = (num) => {\n  if (typeof num !== 'number') return '';\n  return num.toString().replace(/\\B(?=(\\d{3})+(?!\\d))/g, ',');\n}\n\n/**\n * 手机号码脱敏处理\n * @param {string} phone 手机号码\n * @return {string} 脱敏后的手机号码\n */\nconst maskPhone = (phone) => {\n  if (!phone || phone.length !== 11) return phone;\n  return phone.replace(/^(\\d{3})\\d{4}(\\d{4})$/, '$1****$2');\n}\n\n/**\n * 获取当前页面带参数的完整URL\n * @return {string} 当前页面URL\n */\nconst getCurrentPageUrl = () => {\n  const pages = getCurrentPages(); // 获取当前页面栈\n  const currentPage = pages[pages.length - 1]; // 获取当前页面\n  const url = `/${currentPage.route}`; // 当前页面url\n  const options = currentPage.options; // 获取参数\n  \n  // 拼接URL参数\n  let paramStr = '';\n  if (!isEmptyObject(options)) {\n    paramStr = '?' + objectToQuery(options);\n  }\n  \n  return url + paramStr;\n}\n\n/**\n * 设置缓存，支持过期时间\n * @param {string} key 缓存键\n * @param {*} data 缓存数据\n * @param {number} expireTime 过期时间（秒），0表示永不过期\n */\nconst setCache = (key, data, expireTime = 0) => {\n  if (!key) return;\n  \n  const cache = {\n    data,\n    expireTime: expireTime > 0 ? Date.now() + expireTime * 1000 : 0\n  };\n  \n  try {\n    wx.setStorageSync(key, cache);\n  } catch (e) {\n    console.error('设置缓存失败:', e);\n  }\n}\n\n/**\n * 获取缓存，自动处理过期\n * @param {string} key 缓存键\n * @return {*} 缓存数据，过期或不存在返回null\n */\nconst getCache = (key) => {\n  if (!key) return null;\n  \n  try {\n    const cache = wx.getStorageSync(key);\n    \n    if (!cache) return null;\n    \n    // 检查是否过期\n    if (cache.expireTime && cache.expireTime > 0 && cache.expireTime < Date.now()) {\n      wx.removeStorageSync(key); // 移除过期缓存\n      return null;\n    }\n    \n    return cache.data;\n  } catch (e) {\n    console.error('获取缓存失败:', e);\n    return null;\n  }\n}\n\n/**\n * 清除缓存\n * @param {string} key 缓存键\n */\nconst removeCache = (key) => {\n  if (!key) return;\n  \n  try {\n    wx.removeStorageSync(key);\n  } catch (e) {\n    console.error('清除缓存失败:', e);\n  }\n}\n\n/**\n * 清除所有缓存\n */\nconst clearAllCache = () => {\n  try {\n    wx.clearStorageSync();\n  } catch (e) {\n    console.error('清除所有缓存失败:', e);\n  }\n}\n\n/**\n * 显示成功提示\n * @param {string} message 提示信息\n * @param {Function} callback 回调函数\n */\nconst showSuccess = (message, callback) => {\n  wx.showToast({\n    title: message,\n    icon: 'success',\n    duration: 2000,\n    success: callback\n  });\n}\n\n/**\n * 显示失败提示\n * @param {string} message 提示信息\n * @param {Function} callback 回调函数\n */\nconst showError = (message, callback) => {\n  wx.showToast({\n    title: message,\n    icon: 'error',\n    duration: 2000,\n    success: callback\n  });\n}\n\n/**\n * 显示加载提示\n * @param {string} message 提示信息\n */\nconst showLoading = (message = '加载中...') => {\n  wx.showLoading({\n    title: message,\n    mask: true\n  });\n}\n\n/**\n * 隐藏加载提示\n */\nconst hideLoading = () => {\n  wx.hideLoading();\n}\n\n/**\n * 显示模态确认框\n * @param {string} title 标题\n * @param {string} content 内容\n * @param {Function} confirmCallback 确认回调\n * @param {Function} cancelCallback 取消回调\n */\nconst showConfirm = (title, content, confirmCallback, cancelCallback) => {\n  wx.showModal({\n    title,\n    content,\n    success: (res) => {\n      if (res.confirm) {\n        confirmCallback && confirmCallback();\n      } else {\n        cancelCallback && cancelCallback();\n      }\n    }\n  });\n}\n\n/**\n * 上传文件到云存储\n * @param {Object} options 选项\n * @param {string} options.filePath 文件路径\n * @param {string} options.cloudPath 云存储路径\n * @param {Function} options.success 成功回调\n * @param {Function} options.fail 失败回调\n * @param {Function} options.complete 完成回调\n */\nconst uploadFile = (options) => {\n  if (!options.filePath) {\n    options.fail && options.fail({ errMsg: '文件路径不能为空' });\n    return;\n  }\n  \n  if (!options.cloudPath) {\n    // 默认使用时间戳+随机数作为文件名\n    const timestamp = Date.now();\n    const randomNum = Math.floor(Math.random() * 1000);\n    const extension = getFileExtension(options.filePath);\n    options.cloudPath = `upload/${timestamp}_${randomNum}${extension}`;\n  }\n  \n  showLoading('上传中...');\n  \n  wx.cloud.uploadFile({\n    filePath: options.filePath,\n    cloudPath: options.cloudPath,\n    success: (res) => {\n      hideLoading();\n      options.success && options.success(res);\n    },\n    fail: (err) => {\n      hideLoading();\n      showError('上传失败');\n      options.fail && options.fail(err);\n    },\n    complete: options.complete\n  });\n}\n\n/**\n * 预览图片\n * @param {string} url 图片地址\n * @param {Array<string>} urls 图片地址数组\n */\nconst previewImage = (url, urls = []) => {\n  if (!url) return;\n  \n  urls = urls.length > 0 ? urls : [url];\n  \n  wx.previewImage({\n    current: url,\n    urls\n  });\n}\n\n/**\n * 保存图片到相册\n * @param {string} url 图片地址\n * @param {Function} success 成功回调\n * @param {Function} fail 失败回调\n */\nconst saveImageToAlbum = (url, success, fail) => {\n  if (!url) {\n    fail && fail({ errMsg: '图片地址不能为空' });\n    return;\n  }\n  \n  // 先获取用户授权\n  wx.getSetting({\n    success: (res) => {\n      if (!res.authSetting['scope.writePhotosAlbum']) {\n        // 未授权，先获取授权\n        wx.authorize({\n          scope: 'scope.writePhotosAlbum',\n          success: () => {\n            // 授权成功，下载并保存图片\n            downloadAndSaveImage(url, success, fail);\n          },\n          fail: (err) => {\n            console.error('获取保存到相册权限失败:', err);\n            // 用户拒绝授权，引导用户开启授权\n            showConfirm(\n              '提示', \n              '保存图片需要授权访问相册，是否前往设置？',\n              () => {\n                wx.openSetting({\n                  success: (settingRes) => {\n                    if (settingRes.authSetting['scope.writePhotosAlbum']) {\n                      // 用户在设置中授权了，下载并保存图片\n                      downloadAndSaveImage(url, success, fail);\n                    } else {\n                      fail && fail({ errMsg: '用户拒绝授权访问相册' });\n                    }\n                  }\n                });\n              },\n              () => {\n                fail && fail({ errMsg: '用户取消授权访问相册' });\n              }\n            );\n          }\n        });\n      } else {\n        // 已授权，直接下载并保存图片\n        downloadAndSaveImage(url, success, fail);\n      }\n    },\n    fail: (err) => {\n      console.error('获取授权设置失败:', err);\n      fail && fail(err);\n    }\n  });\n}\n\n/**\n * 下载并保存图片到相册（内部函数）\n */\nconst downloadAndSaveImage = (url, success, fail) => {\n  showLoading('保存中...');\n  \n  // 判断是否是网络图片\n  if (url.startsWith('http')) {\n    // 网络图片需要先下载\n    wx.downloadFile({\n      url,\n      success: (res) => {\n        if (res.statusCode === 200) {\n          // 下载成功，保存到相册\n          saveToAlbum(res.tempFilePath, success, fail);\n        } else {\n          hideLoading();\n          fail && fail({ errMsg: `下载图片失败，状态码: ${res.statusCode}` });\n        }\n      },\n      fail: (err) => {\n        hideLoading();\n        console.error('下载图片失败:', err);\n        fail && fail(err);\n      }\n    });\n  } else {\n    // 本地图片直接保存\n    saveToAlbum(url, success, fail);\n  }\n}\n\n/**\n * 保存图片到相册（内部函数）\n */\nconst saveToAlbum = (filePath, success, fail) => {\n  wx.saveImageToPhotosAlbum({\n    filePath,\n    success: (res) => {\n      hideLoading();\n      showSuccess('保存成功');\n      success && success(res);\n    },\n    fail: (err) => {\n      hideLoading();\n      console.error('保存到相册失败:', err);\n      showError('保存失败');\n      fail && fail(err);\n    }\n  });\n}\n\n/**\n * 获取位置信息\n * @param {Object} options 选项\n * @param {Function} options.success 成功回调\n * @param {Function} options.fail 失败回调\n * @param {boolean} options.showLoading 是否显示加载中\n */\nconst getLocation = (options = {}) => {\n  const { success, fail, showLoading: loading = true } = options;\n  \n  if (loading) {\n    showLoading('获取位置中...');\n  }\n  \n  wx.getLocation({\n    type: 'gcj02',\n    success: (res) => {\n      if (loading) hideLoading();\n      success && success(res);\n    },\n    fail: (err) => {\n      if (loading) hideLoading();\n      console.error('获取位置失败:', err);\n      \n      if (err.errMsg.includes('auth deny')) {\n        // 用户拒绝授权\n        showConfirm(\n          '提示', \n          '需要获取您的位置才能使用该功能，是否前往设置？',\n          () => {\n            wx.openSetting({\n              success: (settingRes) => {\n                if (settingRes.authSetting['scope.userLocation']) {\n                  // 用户在设置中授权了，重新获取位置\n                  getLocation(options);\n                } else {\n                  fail && fail({ errMsg: '用户拒绝授权位置信息' });\n                }\n              }\n            });\n          },\n          () => {\n            fail && fail({ errMsg: '用户取消授权位置信息' });\n          }\n        );\n      } else {\n        fail && fail(err);\n      }\n    }\n  });\n}\n\n/**\n * 打开地图选择位置\n * @param {Object} options 选项\n * @param {Function} options.success 成功回调\n * @param {Function} options.fail 失败回调\n */\nconst chooseLocation = (options = {}) => {\n  const { success, fail } = options;\n  \n  wx.chooseLocation({\n    success: (res) => {\n      success && success(res);\n    },\n    fail: (err) => {\n      console.error('选择位置失败:', err);\n      \n      if (err.errMsg.includes('auth deny')) {\n        // 用户拒绝授权\n        showConfirm(\n          '提示', \n          '需要获取您的位置才能使用该功能，是否前往设置？',\n          () => {\n            wx.openSetting({\n              success: (settingRes) => {\n                if (settingRes.authSetting['scope.userLocation']) {\n                  // 用户在设置中授权了，重新选择位置\n                  chooseLocation(options);\n                } else {\n                  fail && fail({ errMsg: '用户拒绝授权位置信息' });\n                }\n              }\n            });\n          },\n          () => {\n            fail && fail({ errMsg: '用户取消授权位置信息' });\n          }\n        );\n      } else {\n        fail && fail(err);\n      }\n    }\n  });\n}\n\n/**\n * 跳转到小程序内页面\n * @param {string} url 页面路径\n * @param {Object} params 页面参数\n */\nconst navigateTo = (url, params = {}) => {\n  if (!url) return;\n  \n  // 添加参数\n  if (!isEmptyObject(params)) {\n    url += (url.indexOf('?') > -1 ? '&' : '?') + objectToQuery(params);\n  }\n  \n  wx.navigateTo({\n    url,\n    fail: (err) => {\n      console.error('页面跳转失败:', err);\n      // 可能是已经打开了太多页面，尝试使用重定向\n      if (err.errMsg.includes('limit exceed')) {\n        wx.redirectTo({ url });\n      }\n    }\n  });\n}\n\n/**\n * 检查并转换单位为rpx\n * @param {string|number} size 尺寸\n * @return {string} 带rpx单位的尺寸\n */\nconst parseSize = (size) => {\n  if (!size) return '0rpx';\n  \n  if (typeof size === 'number') {\n    return `${size}rpx`;\n  }\n  \n  if (typeof size === 'string') {\n    if (/^\\d+$/.test(size)) {\n      return `${size}rpx`;\n    }\n    if (/^\\d+rpx$/.test(size) || /^\\d+px$/.test(size) || /^\\d+%$/.test(size)) {\n      return size;\n    }\n  }\n  \n  return '0rpx';\n}\n\nmodule.exports = {\n  formatTime,\n  formatNumber,\n  formatDate,\n  formatDistance,\n  timeAgo,\n  debounce,\n  throttle,\n  uuid,\n  objectToQuery,\n  queryToObject,\n  deepClone,\n  getFileExtension,\n  formatCurrency,\n  isEmptyObject,\n  formatThousands,\n  maskPhone,\n  getCurrentPageUrl,\n  setCache,\n  getCache,\n  removeCache,\n  clearAllCache,\n  showSuccess,\n  showError,\n  showLoading,\n  hideLoading,\n  showConfirm,\n  uploadFile,\n  previewImage,\n  saveImageToAlbum,\n  getLocation,\n  chooseLocation,\n  navigateTo,\n  parseSize\n}