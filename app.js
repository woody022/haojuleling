// app.js\nconst util = require('./utils/util');\nconst cloudbaseAdapter = require('./utils/cloudbase-adapter');\n\nApp({\n  globalData: {\n    userInfo: null,\n    isLoggedIn: false,\n    isLogin: false, // 增加一个兼容属性，和 isLoggedIn 保持同步\n    isVip: false,\n    vipExpireTime: null,\n    systemInfo: null,\n    statusBarHeight: 0,\n    version: '1.0.0', // 应用版本号\n    prefetchData: null, // 后台预拉取的数据\n    isAgreedPrivacy: false,\n    isOrgUser: false, // 是否是组织用户\n    orgInfo: null, // 组织信息\n    isAdmin: false, // 是否是管理员\n    isSuperAdmin: false, // 是否是超级管理员\n    userId: null, // 添加用户ID字段\n    tabBarIndex: 0, // 底部菜单选中状态\n    location: null, // 用户位置信息\n    hasLocationAuth: false, // 是否有位置权限\n    isGettingLocation: false, // 添加一个标志位，表示正在获取位置\n    totalUnreadMessages: 0, // 未读消息总数\n  },\n  \n  onLaunch() {\n    // 检查隐私协议状态\n    this.checkPrivacyAgreement();\n    console.log('隐私协议同意状态:', this.globalData.isAgreedPrivacy);\n\n    // 初始化 CloudBase 适配器兼容层\n    cloudbaseAdapter.initCloudBaseAdapter();\n    \n    // 初始化云环境\n    if (wx.cloud) {\n      wx.cloud.init({\n        env: 'cloudbase-8go8pejqd6bea684',\n        traceUser: true\n      });\n    } else {\n      console.error('当前基础库版本过低，请升级微信或基础库版本');\n    }\n\n    // 获取状态栏高度（使用新的 API）\n    try {\n      const windowInfo = wx.getWindowInfo();\n      this.globalData.statusBarHeight = windowInfo.statusBarHeight || 0;\n      console.log('状态栏高度:', this.globalData.statusBarHeight);\n    } catch (e) {\n       console.error(\"获取窗口信息失败 (getWindowInfo):\", e);\n       this.globalData.statusBarHeight = 0; // Default value on error\n    }\n    \n    // 已同意隐私，则初始化后台预拉取\n    if (this.globalData.isAgreedPrivacy) {\n      this.initBackgroundFetch();\n    }\n    \n    // 初始化检查登录状态\n    this.checkLoginStatus();\n\n    // 初始化用户信息\n    this.initUserInfo();\n\n    // 检查组织登录状态（确保在云环境初始化后调用）\n    const isOrgUser = this.checkOrgLoginStatus();\n    \n    // 检查位置权限并获取位置\n    this.checkLocationAuth();\n    \n    // 如果是组织用户，获取未读消息数量\n    if (isOrgUser) {\n      setTimeout(() => {\n        this.getUnreadMessageCount();\n      }, 1500);\n    }\n  },\n  \n  // 检查隐私协议状态\n  checkPrivacyAgreement() {\n    // 从本地存储获取隐私协议同意状态\n    const isAgreedPrivacy = wx.getStorageSync('isAgreedPrivacy') || false;\n    this.globalData.isAgreedPrivacy = isAgreedPrivacy;\n    return isAgreedPrivacy;\n  },\n  \n  // 确保用户已同意隐私协议\n  ensurePrivacyAgreement(callback, sceneName = '') {\n    if (this.globalData.isAgreedPrivacy) {\n      // 已同意隐私协议，直接执行回调\n      callback && callback(true);\n      return true;\n    } else {\n      // 未同意隐私协议，显示隐私协议弹窗\n      this.showPrivacyAgreement(callback, sceneName);\n      return false;\n    }\n  },\n  \n  // 显示隐私协议弹窗\n  showPrivacyAgreement(callback, sceneName = '') {\n    // 使用微信小程序提供的隐私协议弹窗\n    if (wx.requirePrivacyAuthorize && wx.onPrivacyAuthorizeChanged) {\n      // 记录场景名称，用于日志\n      console.log('显示隐私协议弹窗，场景:', sceneName || '未指定');\n      \n      wx.onPrivacyAuthorizeChanged(status => {\n        console.log('隐私授权状态改变:', status);\n        if (status) {\n          // 用户同意隐私协议\n          wx.setStorageSync('isAgreedPrivacy', true);\n          this.globalData.isAgreedPrivacy = true;\n          console.log('用户同意隐私协议');\n          callback && callback(true);\n          \n          // 初始化后台预拉取\n          this.initBackgroundFetch();\n        } else {\n          // 用户拒绝隐私协议\n          wx.setStorageSync('isAgreedPrivacy', false);\n          this.globalData.isAgreedPrivacy = false;\n          console.log('用户拒绝隐私协议');\n          callback && callback(false);\n        }\n      });\n      \n      wx.requirePrivacyAuthorize({\n        success: () => {\n          // 用户已经授权过或刚刚同意了授权\n          console.log('隐私授权成功');\n          wx.setStorageSync('isAgreedPrivacy', true);\n          this.globalData.isAgreedPrivacy = true;\n          callback && callback(true);\n          \n          // 初始化后台预拉取\n          this.initBackgroundFetch();\n        },\n        fail: err => {\n          // 用户拒绝了授权或其他原因导致的失败\n          console.log('隐私授权失败:', err);\n          callback && callback(false);\n        }\n      });\n    } else {\n      // 兼容不支持新隐私API的旧版本微信\n      this.showLegacyPrivacyAgreement(callback);\n    }\n  },\n  \n  // 旧版隐私协议弹窗（兼容旧版微信）\n  showLegacyPrivacyAgreement(callback) {\n    wx.showModal({\n      title: '隐私保护提示',\n      content: '感谢您使用好聚乐龄微信小程序！我们非常重视您的个人信息和隐私保护。为了更好地保障您的权益，请您在使用我们的产品前，详细阅读我们的《隐私保护指引》，了解我们收集、使用、存储和保护您个人信息的规则。\\n\\n点击"同意"即表示您已阅读并同意我们的隐私条款。',\n      confirmText: '同意',\n      cancelText: '不同意',\n      success: res => {\n        if (res.confirm) {\n          // 用户点击了同意按钮\n          wx.setStorageSync('isAgreedPrivacy', true);\n          this.globalData.isAgreedPrivacy = true;\n          console.log('用户同意隐私协议（旧版接口）');\n          callback && callback(true);\n          \n          // 初始化后台预拉取\n          this.initBackgroundFetch();\n        } else {\n          // 用户点击了不同意按钮\n          wx.setStorageSync('isAgreedPrivacy', false);\n          this.globalData.isAgreedPrivacy = false;\n          console.log('用户拒绝隐私协议（旧版接口）');\n          callback && callback(false);\n        }\n      },\n      fail: err => {\n        console.error('显示隐私协议弹窗失败:', err);\n        callback && callback(false);\n      }\n    });\n  },\n  \n  // 检查登录状态\n  async checkLoginStatus() {\n    try {\n      // 从本地存储获取token\n      const token = wx.getStorageSync('token') || '';\n      if (!token) {\n        console.log('未找到登录令牌，用户未登录');\n        this.clearLoginState();\n        return false;\n      }\n      \n      // 验证token有效性\n      const isValid = await this.verifyToken(token);\n      if (isValid) {\n        console.log('登录令牌有效，用户已登录');\n        this.globalData.isLoggedIn = true;\n        this.globalData.isLogin = true; // 保持同步\n        \n        // 检查会员状态\n        this.checkVipStatus();\n        return true;\n      } else {\n        console.log('登录令牌无效，需要重新登录');\n        this.clearLoginState();\n        return false;\n      }\n    } catch (error) {\n      console.error('检查登录状态失败:', error);\n      this.clearLoginState();\n      return false;\n    }\n  },\n  \n  // 验证token有效性\n  verifyToken(token) {\n    return new Promise((resolve, reject) => {\n      if (!token) {\n        resolve(false);\n        return;\n      }\n      \n      // 调用云函数验证token\n      wx.cloud.callFunction({\n        name: 'auth',\n        data: {\n          action: 'verifyToken',\n          token: token\n        },\n        success: res => {\n          const result = res.result || {};\n          if (result.code === 0 && result.data && result.data.isValid) {\n            // 更新用户ID\n            if (result.data.userId) {\n              this.globalData.userId = result.data.userId;\n            }\n            resolve(true);\n          } else {\n            resolve(false);\n          }\n        },\n        fail: err => {\n          console.error('验证token失败:', err);\n          reject(err);\n        }\n      });\n    });\n  },\n  \n  // 清除登录状态\n  clearLoginState() {\n    // 清除登录相关的本地存储和全局数据\n    this.globalData.isLoggedIn = false;\n    this.globalData.isLogin = false; // 保持同步\n    this.globalData.userInfo = null;\n    this.globalData.isVip = false;\n    this.globalData.vipExpireTime = null;\n    this.globalData.userId = null;\n    \n    wx.removeStorageSync('token');\n    wx.removeStorageSync('userInfo');\n    wx.removeStorageSync('vipInfo');\n    \n    // 如果有组织登录状态，也一并清除\n    this.clearOrgLoginState();\n  },\n  \n  // 检查会员状态\n  checkVipStatus() {\n    // 从本地存储读取会员信息\n    const vipInfo = wx.getStorageSync('vipInfo') || {};\n    if (!vipInfo.expireTime) {\n      console.log('无会员信息或会员信息不完整');\n      this.globalData.isVip = false;\n      this.globalData.vipExpireTime = null;\n      return false;\n    }\n    \n    const expireTime = new Date(vipInfo.expireTime);\n    const now = new Date();\n    \n    if (expireTime > now) {\n      // 会员未过期\n      this.globalData.isVip = true;\n      this.globalData.vipExpireTime = expireTime;\n      console.log('会员有效，到期时间:', expireTime.toLocaleString());\n      return true;\n    } else {\n      // 会员已过期\n      this.globalData.isVip = false;\n      this.globalData.vipExpireTime = expireTime;\n      console.log('会员已过期，过期时间:', expireTime.toLocaleString());\n      return false;\n    }\n  },\n  \n  // 初始化用户信息\n  initUserInfo() {\n    // 从本地存储读取用户信息\n    const userInfo = wx.getStorageSync('userInfo');\n    if (userInfo) {\n      this.globalData.userInfo = userInfo;\n      console.log('已从本地存储读取用户信息');\n    }\n  },\n  \n  // 检查组织登录状态\n  checkOrgLoginStatus() {\n    try {\n      // 从本地存储获取组织token\n      const orgToken = wx.getStorageSync('orgToken') || '';\n      const orgInfo = wx.getStorageSync('orgInfo') || null;\n      \n      if (!orgToken || !orgInfo) {\n        console.log('未找到组织登录令牌或组织信息，非组织用户');\n        this.globalData.isOrgUser = false;\n        this.globalData.orgInfo = null;\n        return false;\n      }\n      \n      // 设置组织用户标志和组织信息\n      this.globalData.isOrgUser = true;\n      this.globalData.orgInfo = orgInfo;\n      console.log('已从本地存储读取组织信息:', orgInfo.name);\n      \n      return true;\n    } catch (error) {\n      console.error('检查组织登录状态失败:', error);\n      this.globalData.isOrgUser = false;\n      this.globalData.orgInfo = null;\n      return false;\n    }\n  },\n  \n  // 清除组织登录状态\n  clearOrgLoginState() {\n    this.globalData.isOrgUser = false;\n    this.globalData.orgInfo = null;\n    \n    wx.removeStorageSync('orgToken');\n    wx.removeStorageSync('orgInfo');\n  },\n  \n  // 切换到组织中心页面\n  switchToOrgCenter() {\n    wx.switchTab({\n      url: '/pages/organization/orgCenter/orgCenter',\n      fail: (err) => {\n        console.error('切换到组织中心失败:', err);\n        // 如果是非tabBar页面，使用redirectTo\n        wx.redirectTo({\n          url: '/pages/organization/orgCenter/orgCenter',\n          fail: (redirectErr) => {\n            console.error('重定向到组织中心也失败:', redirectErr);\n          }\n        });\n      }\n    });\n  },\n  \n  // 获取未读消息数量\n  getUnreadMessageCount(callback) {\n    if (!this.globalData.isLoggedIn || !this.globalData.isOrgUser) {\n      console.log('用户未登录或非组织用户，不获取未读消息数量');\n      this.updateMessageBadge(0);\n      callback && callback(0);\n      return;\n    }\n    \n    wx.cloud.callFunction({\n      name: 'message',\n      data: {\n        action: 'getUnreadCount',\n        orgId: this.globalData.orgInfo ? this.globalData.orgInfo._id : ''\n      },\n      success: res => {\n        console.log('获取未读消息数量成功:', res);\n        const result = res.result || {};\n        if (result.code === 0) {\n          const count = result.data.count || 0;\n          this.globalData.totalUnreadMessages = count;\n          \n          // 更新消息图标上的红点\n          this.updateMessageBadge(count);\n          \n          callback && callback(count);\n        } else {\n          console.error('获取未读消息数量接口返回错误:', result.message);\n          callback && callback(0);\n        }\n      },\n      fail: err => {\n        console.error('获取未读消息数量失败:', err);\n        callback && callback(0);\n      }\n    });\n  },\n  \n  // 更新消息图标上的红点\n  updateMessageBadge(count) {\n    if (count > 0) {\n      // 设置tabBar的右上角红点\n      if (typeof count === 'number' && count > 0) {\n        // 如果count是数字且大于0，显示具体数量\n        wx.setTabBarBadge({\n          index: 1, // 消息tab的索引\n          text: count > 99 ? '99+' : count.toString(),\n          fail: (err) => {\n            console.log('设置TabBar红点失败（可能是在非TabBar页面）:', err);\n          }\n        });\n      } else {\n        // 否则只显示红点\n        wx.showTabBarRedDot({\n          index: 1,\n          fail: (err) => {\n            console.log('设置TabBar红点失败（可能是在非TabBar页面）:', err);\n          }\n        });\n      }\n    } else {\n      // 移除tabBar的右上角红点\n      wx.hideTabBarRedDot({\n        index: 1,\n        fail: (err) => {\n          console.log('移除TabBar红点失败（可能是在非TabBar页面）:', err);\n        }\n      });\n      \n      // 同时移除数字\n      wx.removeTabBarBadge({\n        index: 1,\n        fail: (err) => {\n          console.log('移除TabBar数字失败（可能是在非TabBar页面）:', err);\n        }\n      });\n    }\n  },\n  \n  // 更新底部TabBar选中状态\n  updateTabBarSelection(index) {\n    // 保存当前选中的索引\n    this.globalData.tabBarIndex = index;\n    \n    // 如果使用自定义tabBar，需要更新自定义tabBar组件的选中状态\n    const customTabBar = this.getTabBar();\n    if (customTabBar) {\n      customTabBar.setData({\n        selected: index\n      });\n    }\n  },\n  \n  // 检查位置权限\n  checkLocationAuth() {\n    // 检查位置权限\n    wx.getSetting({\n      success: res => {\n        // 使用 === undefined 而不是 !res.authSetting 以避免将 false 解释为未授权\n        if (res.authSetting['scope.userLocation'] === undefined) {\n          // 首次使用，未请求过授权\n          console.log('用户首次使用，未请求过位置授权');\n          this.globalData.hasLocationAuth = false;\n        } else if (res.authSetting['scope.userLocation'] === false) {\n          // 用户拒绝过授权\n          console.log('用户拒绝过位置授权');\n          this.globalData.hasLocationAuth = false;\n        } else {\n          // 已授权\n          console.log('用户已授权位置权限');\n          this.globalData.hasLocationAuth = true;\n          \n          // 获取位置信息\n          this.getLocation();\n        }\n      },\n      fail: err => {\n        console.error('获取用户授权设置失败:', err);\n        this.globalData.hasLocationAuth = false;\n      }\n    });\n  },\n  \n  // 获取位置信息\n  getLocation() {\n    // 检查是否正在获取位置\n    if (this.globalData.isGettingLocation) {\n      console.log('正在获取位置信息，请稍候...');\n      return;\n    }\n    \n    // 标记为正在获取位置\n    this.globalData.isGettingLocation = true;\n    \n    // 尝试使用新API\n    const useNewAPI = () => {\n      wx.getLocation({\n        type: 'gcj02',\n        isHighAccuracy: true,\n        highAccuracyExpireTime: 3000,\n        success: handleLocationSuccess,\n        fail: (err) => {\n          console.log('新API获取位置失败，尝试旧API:', err);\n          // 如果新API失败，尝试使用旧API\n          useLegacyAPI();\n        }\n      });\n    };\n    \n    // 旧API兼容方案\n    const useLegacyAPI = () => {\n      wx.getLocation({\n        type: 'gcj02',\n        success: handleLocationSuccess,\n        fail: (err) => {\n          console.error('获取位置信息失败:', err);\n          handleLocationError(err);\n        },\n        complete: () => {\n          // 标记为不再获取位置\n          this.globalData.isGettingLocation = false;\n        }\n      });\n    };\n    \n    // 处理位置获取成功\n    const handleLocationSuccess = (res) => {\n      console.log('获取位置信息成功:', res);\n      \n      // 保存位置信息到全局数据\n      this.globalData.location = {\n        latitude: res.latitude,\n        longitude: res.longitude,\n        accuracy: res.accuracy,\n        horizontalAccuracy: res.horizontalAccuracy,\n        verticalAccuracy: res.verticalAccuracy,\n        speed: res.speed,\n        altitude: res.altitude,\n        timestamp: new Date().getTime()\n      };\n      \n      // 保存到本地存储，方便下次使用\n      wx.setStorageSync('lastLocation', this.globalData.location);\n      \n      // 标记为不再获取位置\n      this.globalData.isGettingLocation = false;\n      \n      // 标记为有位置权限\n      this.globalData.hasLocationAuth = true;\n    };\n    \n    // 处理位置获取失败\n    const handleLocationError = (err) => {\n      // 错误处理\n      let errMsg = err.errMsg || '';\n      \n      if (errMsg.includes('auth deny')) {\n        // 用户拒绝授权\n        console.log('用户拒绝位置授权');\n        this.globalData.hasLocationAuth = false;\n      } else if (errMsg.includes('system permission denied')) {\n        // 系统权限被拒绝\n        console.log('系统拒绝位置授权，可能需要在系统设置中允许');\n        this.globalData.hasLocationAuth = false;\n      } else {\n        // 其他错误\n        console.error('获取位置失败:', errMsg);\n        \n        // 尝试使用上次保存的位置\n        const lastLocation = wx.getStorageSync('lastLocation');\n        if (lastLocation) {\n          console.log('使用上次保存的位置信息:', lastLocation);\n          this.globalData.location = lastLocation;\n        }\n      }\n      \n      // 标记为不再获取位置\n      this.globalData.isGettingLocation = false;\n    };\n    \n    // 开始获取位置\n    useNewAPI();\n  }\n});